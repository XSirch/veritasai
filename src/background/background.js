/**
 * VeritasAI - Background Service Worker (Groq Only)
 * Vers√£o simplificada usando apenas Groq AI
 */

console.log('üöÄ VeritasAI Background Service iniciando (Groq Only)...');

// Configura√ß√£o padr√£o - apenas Groq AI
const DEFAULT_CONFIG = {
  groqApiKey: '',
  groqModel: 'llama3-70b-8192', // Modelo padr√£o atualizado
  language: 'pt-BR',
  theme: 'auto',
  notificationsEnabled: true,
  soundEnabled: false,
  autoVerify: false,
  cacheEnabled: true,
  apiTimeout: 30,
  maxTextLength: 5000,
  debugMode: false,
  verboseLogging: false
};

// Configurar listener de mensagens principal
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log('üì® Mensagem recebida:', request.action, request);
  
  (async () => {
    try {
      let response;
      
      switch (request.action) {
        case 'getConfiguration':
        case 'getSettings':
          console.log('üìã Processando getConfiguration...');
          response = await handleGetConfiguration();
          break;
          
        case 'saveConfiguration':
        case 'updateSettings':
          console.log('üíæ Processando saveConfiguration...');
          response = await handleSaveConfiguration(request.config);

          // Notificar content scripts sobre atualiza√ß√£o de configura√ß√µes
          if (response.success) {
            console.log('üì¢ Notificando content scripts sobre atualiza√ß√£o de configura√ß√µes...');
            chrome.tabs.query({}, (tabs) => {
              tabs.forEach(tab => {
                chrome.tabs.sendMessage(tab.id, { action: 'settingsUpdated' }).catch(() => {
                  // Ignorar erros para tabs que n√£o t√™m content script
                });
              });
            });
          }
          break;
          
        case 'verifyText':
          console.log('üîç Processando verifyText...');
          response = await handleVerifyTextWithGroq(request);
          break;
          
        case 'testGroqApi':
          console.log('üß™ Testando Groq API...');
          response = await testGroqApiKey(request.apiKey, request.model);
          break;
          
        default:
          console.warn('‚ö†Ô∏è A√ß√£o n√£o reconhecida:', request.action);
          response = { 
            success: false, 
            error: `A√ß√£o n√£o reconhecida: ${request.action}` 
          };
      }
      
      console.log('üì§ Enviando resposta:', response);
      sendResponse(response);
      
    } catch (error) {
      console.error('‚ùå Erro no background script:', error);
      sendResponse({ 
        success: false, 
        error: error.message 
      });
    }
  })();
  
  return true; // Manter canal aberto para resposta ass√≠ncrona
});

/**
 * Manipula obten√ß√£o de configura√ß√£o
 */
async function handleGetConfiguration() {
  try {
    const result = await chrome.storage.sync.get(['veritasConfig']);
    const config = result.veritasConfig || DEFAULT_CONFIG;

    return {
      success: true,
      data: config,        // ‚úÖ Mudado de 'config' para 'data'
      config: config,      // ‚úÖ Mantido para compatibilidade com popup
      hasGroqKey: !!(config.groqApiKey && config.groqApiKey.length > 20)
    };
  } catch (error) {
    console.error('‚ùå Erro ao obter configura√ß√£o:', error);
    return {
      success: false,
      error: error.message,
      data: DEFAULT_CONFIG,  // ‚úÖ Mudado de 'config' para 'data'
      config: DEFAULT_CONFIG // ‚úÖ Mantido para compatibilidade
    };
  }
}

/**
 * Manipula salvamento de configura√ß√£o
 */
async function handleSaveConfiguration(newConfig) {
  try {
    const configToSave = { ...DEFAULT_CONFIG, ...newConfig };
    
    await chrome.storage.sync.set({ veritasConfig: configToSave });
    
    console.log('‚úÖ Configura√ß√£o salva:', configToSave);
    
    return {
      success: true,
      config: configToSave,
      message: 'Configura√ß√£o salva com sucesso'
    };
  } catch (error) {
    console.error('‚ùå Erro ao salvar configura√ß√£o:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

/**
 * Manipula verifica√ß√£o de texto usando apenas Groq AI
 */
async function handleVerifyTextWithGroq(request) {
  const startTime = Date.now();
  const text = request.text;
  
  console.log('üîç Iniciando verifica√ß√£o com Groq AI:', text.substring(0, 100) + '...');
  
  try {
    // Obter configura√ß√£o
    const configResult = await chrome.storage.sync.get(['veritasConfig']);
    const config = configResult.veritasConfig || DEFAULT_CONFIG;
    const groqApiKey = config.groqApiKey;
    const groqModel = config.groqModel || DEFAULT_CONFIG.groqModel;

    console.log('üîë Configura√ß√£o carregada:', {
      hasConfig: !!config,
      hasGroqKey: !!(groqApiKey && groqApiKey.length > 20),
      groqModel: groqModel
    });
    
    if (!groqApiKey || groqApiKey.trim() === '') {
      return {
        success: false,
        error: 'Groq API Key n√£o configurada',
        data: {
          classification: 'erro',
          confidence: 0.0,
          summary: 'Configure sua Groq API Key nas op√ß√µes da extens√£o para usar a verifica√ß√£o de fatos.',
          sources: ['VeritasAI (Configura√ß√£o)'],
          details: {
            strategy: 'no-api-key',
            processingTime: Date.now() - startTime,
            note: 'Groq API Key necess√°ria para verifica√ß√£o'
          }
        }
      };
    }

    console.log('ü§ñ Fazendo requisi√ß√£o para Groq API...');
    
    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${groqApiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: groqModel,
        messages: [
          {
            role: 'system',
            content: `Voc√™ √© um especialista em verifica√ß√£o de fatos. Analise o texto fornecido e determine:
1. Se √© uma afirma√ß√£o factual verific√°vel
2. Sua veracidade baseada em conhecimento geral
3. N√≠vel de confian√ßa na an√°lise

Responda APENAS em formato JSON:
{
  "classification": "confi√°vel|inconclusiva|sem fundamento",
  "confidence": 0.0-1.0,
  "summary": "Explica√ß√£o detalhada da an√°lise",
  "reasoning": "Justificativa da classifica√ß√£o"
}`
          },
          {
            role: 'user',
            content: `Analise este texto: "${text}"`
          }
        ],
        temperature: 0.3,
        max_tokens: 500
      })
    });

    // Tratamento espec√≠fico para erro 429 (Rate Limit)
    if (response.status === 429) {
      console.warn('‚ö†Ô∏è Groq API: Limite de requisi√ß√µes atingido (429)');
      
      return {
        success: true,
        data: {
          classification: 'inconclusiva',
          confidence: 0.3,
          summary: 'Limite di√°rio de verifica√ß√µes atingido. Os cr√©ditos da API Groq ser√£o renovados automaticamente amanh√£. Tente novamente em algumas horas.',
          sources: ['VeritasAI (Limite Atingido)'],
          details: {
            strategy: 'groq-rate-limited',
            processingTime: Date.now() - startTime,
            error: 'Rate limit exceeded (429)',
            note: 'Cr√©ditos di√°rios esgotados. Renova√ß√£o autom√°tica amanh√£.'
          }
        }
      };
    }

    if (!response.ok) {
      const errorData = await response.json().catch(() => null);
      console.error('‚ùå Erro da Groq API:', errorData);
      throw new Error(`Groq API Error: ${response.status} - ${response.statusText}`);
    }

    const data = await response.json();
    const aiResponse = data.choices[0]?.message?.content;

    if (!aiResponse) {
      throw new Error('Resposta vazia do Groq');
    }

    console.log('üìä Resposta da Groq recebida:', aiResponse.substring(0, 100) + '...');

    // Tentar parsear resposta JSON
    let analysis;
    try {
      analysis = JSON.parse(aiResponse);
    } catch (parseError) {
      console.warn('‚ö†Ô∏è Erro ao parsear resposta do Groq, usando fallback');
      analysis = {
        classification: 'inconclusiva',
        confidence: 0.4,
        summary: aiResponse.substring(0, 200) + '...',
        reasoning: 'An√°lise baseada em IA'
      };
    }

    return {
      success: true,
      data: {
        classification: analysis.classification || 'inconclusiva',
        confidence: Math.min(0.9, analysis.confidence || 0.4),
        summary: analysis.summary || 'An√°lise realizada por IA',
        sources: ['Groq AI (Llama 3.1)'],
        details: {
          strategy: 'groq-ai',
          processingTime: Date.now() - startTime,
          reasoning: analysis.reasoning,
          note: 'An√°lise realizada por intelig√™ncia artificial'
        }
      }
    };

  } catch (error) {
    console.error('‚ùå Erro na verifica√ß√£o:', error);
    
    // Verificar se √© erro de rate limit n√£o capturado
    if (error.message.includes('429') || error.message.includes('rate limit')) {
      return {
        success: true,
        data: {
          classification: 'inconclusiva',
          confidence: 0.3,
          summary: 'Limite de uso da API atingido. Tente novamente amanh√£ quando os cr√©ditos forem renovados.',
          sources: ['VeritasAI (Limite Atingido)'],
          details: {
            strategy: 'groq-rate-limited',
            processingTime: Date.now() - startTime,
            error: error.message,
            note: 'Cr√©ditos di√°rios da API Groq esgotados'
          }
        }
      };
    }

    return {
      success: false,
      error: error.message,
      data: {
        classification: 'erro',
        confidence: 0.0,
        summary: `Erro na verifica√ß√£o: ${error.message}`,
        sources: ['VeritasAI (Erro)'],
        details: {
          strategy: 'groq-error',
          processingTime: Date.now() - startTime,
          error: error.message,
          note: 'Erro ao conectar com a API Groq'
        }
      }
    };
  }
}

/**
 * Testa se a API Key do Groq √© v√°lida
 */
async function testGroqApiKey(apiKey, model = DEFAULT_CONFIG.groqModel) {
  console.log('üß™ Testando Groq API Key:', apiKey?.substring(0, 10) + '...', 'Modelo:', model);

  if (!apiKey || apiKey.trim() === '') {
    return {
      success: false,
      error: 'API Key n√£o fornecida',
      details: 'Por favor, insira uma Groq API Key v√°lida'
    };
  }

  try {
    // Fazer uma requisi√ß√£o simples para testar a API Key
    const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        model: model,
        messages: [
          {
            role: 'user',
            content: 'Teste de conectividade. Responda apenas "OK".'
          }
        ],
        max_tokens: 10
      })
    });

    if (response.ok) {
      const data = await response.json();
      return {
        success: true,
        message: 'Groq API Key v√°lida e funcionando!',
        details: `Teste realizado com sucesso. Modelo: ${model}`
      };
    } else if (response.status === 429) {
      return {
        success: false,
        error: 'Rate limit atingido',
        details: 'API Key v√°lida, mas limite de requisi√ß√µes atingido. Tente novamente mais tarde.'
      };
    } else {
      const errorData = await response.json().catch(() => null);

      if (response.status === 401) {
        return {
          success: false,
          error: 'API Key inv√°lida',
          details: 'Verifique se a Groq API Key est√° correta'
        };
      }

      return {
        success: false,
        error: `Erro HTTP ${response.status}`,
        details: errorData?.error?.message || response.statusText
      };
    }

  } catch (error) {
    console.error('‚ùå Erro no teste da Groq API:', error);
    return {
      success: false,
      error: 'Erro de conex√£o',
      details: error.message
    };
  }
}

// Listeners de instala√ß√£o e inicializa√ß√£o
chrome.runtime.onInstalled.addListener((details) => {
  console.log('üéâ Extens√£o instalada/atualizada:', details.reason);
});

console.log('‚úÖ Background Service carregado e listeners ativos (Groq Only)');
